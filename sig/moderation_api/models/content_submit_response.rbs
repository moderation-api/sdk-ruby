module ModerationAPI
  module Models
    type content_submit_response =
      {
        author: ModerationAPI::Models::ContentSubmitResponse::Author?,
        content: ModerationAPI::Models::ContentSubmitResponse::Content,
        evaluation: ModerationAPI::Models::ContentSubmitResponse::Evaluation,
        insights: ::Array[ModerationAPI::Models::ContentSubmitResponse::insight],
        meta: ModerationAPI::Models::ContentSubmitResponse::Meta,
        policies: ::Array[ModerationAPI::Models::ContentSubmitResponse::policy],
        recommendation: ModerationAPI::Models::ContentSubmitResponse::Recommendation,
        errors: ::Array[ModerationAPI::Models::ContentSubmitResponse::Error]
      }

    class ContentSubmitResponse < ModerationAPI::Internal::Type::BaseModel
      attr_accessor author: ModerationAPI::Models::ContentSubmitResponse::Author?

      attr_accessor content: ModerationAPI::Models::ContentSubmitResponse::Content

      attr_accessor evaluation: ModerationAPI::Models::ContentSubmitResponse::Evaluation

      attr_accessor insights: ::Array[ModerationAPI::Models::ContentSubmitResponse::insight]

      attr_accessor meta: ModerationAPI::Models::ContentSubmitResponse::Meta

      attr_accessor policies: ::Array[ModerationAPI::Models::ContentSubmitResponse::policy]

      attr_accessor recommendation: ModerationAPI::Models::ContentSubmitResponse::Recommendation

      attr_reader errors: ::Array[ModerationAPI::Models::ContentSubmitResponse::Error]?

      def errors=: (
        ::Array[ModerationAPI::Models::ContentSubmitResponse::Error]
      ) -> ::Array[ModerationAPI::Models::ContentSubmitResponse::Error]

      def initialize: (
        author: ModerationAPI::Models::ContentSubmitResponse::Author?,
        content: ModerationAPI::Models::ContentSubmitResponse::Content,
        evaluation: ModerationAPI::Models::ContentSubmitResponse::Evaluation,
        insights: ::Array[ModerationAPI::Models::ContentSubmitResponse::insight],
        meta: ModerationAPI::Models::ContentSubmitResponse::Meta,
        policies: ::Array[ModerationAPI::Models::ContentSubmitResponse::policy],
        recommendation: ModerationAPI::Models::ContentSubmitResponse::Recommendation,
        ?errors: ::Array[ModerationAPI::Models::ContentSubmitResponse::Error]
      ) -> void

      def to_hash: -> {
        author: ModerationAPI::Models::ContentSubmitResponse::Author?,
        content: ModerationAPI::Models::ContentSubmitResponse::Content,
        evaluation: ModerationAPI::Models::ContentSubmitResponse::Evaluation,
        insights: ::Array[ModerationAPI::Models::ContentSubmitResponse::insight],
        meta: ModerationAPI::Models::ContentSubmitResponse::Meta,
        policies: ::Array[ModerationAPI::Models::ContentSubmitResponse::policy],
        recommendation: ModerationAPI::Models::ContentSubmitResponse::Recommendation,
        errors: ::Array[ModerationAPI::Models::ContentSubmitResponse::Error]
      }

      type author =
        {
          id: String,
          block: ModerationAPI::Models::ContentSubmitResponse::Author::Block?,
          status: ModerationAPI::Models::ContentSubmitResponse::Author::status,
          trust_level: ModerationAPI::Models::ContentSubmitResponse::Author::TrustLevel,
          external_id: String?
        }

      class Author < ModerationAPI::Internal::Type::BaseModel
        attr_accessor id: String

        attr_accessor block: ModerationAPI::Models::ContentSubmitResponse::Author::Block?

        attr_accessor status: ModerationAPI::Models::ContentSubmitResponse::Author::status

        attr_accessor trust_level: ModerationAPI::Models::ContentSubmitResponse::Author::TrustLevel

        attr_accessor external_id: String?

        def initialize: (
          id: String,
          block: ModerationAPI::Models::ContentSubmitResponse::Author::Block?,
          status: ModerationAPI::Models::ContentSubmitResponse::Author::status,
          trust_level: ModerationAPI::Models::ContentSubmitResponse::Author::TrustLevel,
          ?external_id: String?
        ) -> void

        def to_hash: -> {
          id: String,
          block: ModerationAPI::Models::ContentSubmitResponse::Author::Block?,
          status: ModerationAPI::Models::ContentSubmitResponse::Author::status,
          trust_level: ModerationAPI::Models::ContentSubmitResponse::Author::TrustLevel,
          external_id: String?
        }

        type block = { reason: String?, until_: Float? }

        class Block < ModerationAPI::Internal::Type::BaseModel
          attr_accessor reason: String?

          attr_accessor until_: Float?

          def initialize: (?reason: String?, ?until_: Float?) -> void

          def to_hash: -> { reason: String?, until_: Float? }
        end

        type status = :enabled | :suspended | :blocked

        module Status
          extend ModerationAPI::Internal::Type::Enum

          ENABLED: :enabled
          SUSPENDED: :suspended
          BLOCKED: :blocked

          def self?.values: -> ::Array[ModerationAPI::Models::ContentSubmitResponse::Author::status]
        end

        type trust_level = { level: Float, manual: bool }

        class TrustLevel < ModerationAPI::Internal::Type::BaseModel
          attr_accessor level: Float

          attr_accessor manual: bool

          def initialize: (level: Float, manual: bool) -> void

          def to_hash: -> { level: Float, manual: bool }
        end
      end

      type content =
        {
          id: String,
          masked: bool,
          modified: ModerationAPI::Models::ContentSubmitResponse::Content::modified?
        }

      class Content < ModerationAPI::Internal::Type::BaseModel
        attr_accessor id: String

        attr_accessor masked: bool

        attr_accessor modified: ModerationAPI::Models::ContentSubmitResponse::Content::modified?

        def initialize: (
          id: String,
          masked: bool,
          modified: ModerationAPI::Models::ContentSubmitResponse::Content::modified?
        ) -> void

        def to_hash: -> {
          id: String,
          masked: bool,
          modified: ModerationAPI::Models::ContentSubmitResponse::Content::modified?
        }

        type modified =
          String
          | ::Hash[Symbol, top]
          | ::Hash[Symbol, ModerationAPI::Models::ContentSubmitResponse::Content::Modified::modified_nested_object_content]

        module Modified
          extend ModerationAPI::Internal::Type::Union

          type modified_nested_object_content =
            ModerationAPI::Models::ContentSubmitResponse::Content::Modified::ModifiedNestedObjectContent::Text
            | ModerationAPI::Models::ContentSubmitResponse::Content::Modified::ModifiedNestedObjectContent::Image
            | ModerationAPI::Models::ContentSubmitResponse::Content::Modified::ModifiedNestedObjectContent::Video
            | ModerationAPI::Models::ContentSubmitResponse::Content::Modified::ModifiedNestedObjectContent::Audio

          module ModifiedNestedObjectContent
            extend ModerationAPI::Internal::Type::Union

            type text = { text: String, type: :text }

            class Text < ModerationAPI::Internal::Type::BaseModel
              attr_accessor text: String

              attr_accessor type: :text

              def initialize: (text: String, ?type: :text) -> void

              def to_hash: -> { text: String, type: :text }
            end

            type image = { type: :image, data: String, url: String }

            class Image < ModerationAPI::Internal::Type::BaseModel
              attr_accessor type: :image

              attr_reader data: String?

              def data=: (String) -> String

              attr_reader url: String?

              def url=: (String) -> String

              def initialize: (
                ?data: String,
                ?url: String,
                ?type: :image
              ) -> void

              def to_hash: -> { type: :image, data: String, url: String }
            end

            type video = { type: :video, url: String }

            class Video < ModerationAPI::Internal::Type::BaseModel
              attr_accessor type: :video

              attr_accessor url: String

              def initialize: (url: String, ?type: :video) -> void

              def to_hash: -> { type: :video, url: String }
            end

            type audio = { type: :audio, url: String }

            class Audio < ModerationAPI::Internal::Type::BaseModel
              attr_accessor type: :audio

              attr_accessor url: String

              def initialize: (url: String, ?type: :audio) -> void

              def to_hash: -> { type: :audio, url: String }
            end

            def self?.variants: -> ::Array[ModerationAPI::Models::ContentSubmitResponse::Content::Modified::modified_nested_object_content]
          end

          def self?.variants: -> ::Array[ModerationAPI::Models::ContentSubmitResponse::Content::modified]

          ModifiedObjectContentMap: ModerationAPI::Internal::Type::Converter

          ModifiedNestedObjectContentMap: ModerationAPI::Internal::Type::Converter
        end
      end

      type evaluation =
        {
          flag_probability: Float,
          flagged: bool,
          severity_score: Float,
          unicode_spoofed: bool
        }

      class Evaluation < ModerationAPI::Internal::Type::BaseModel
        attr_accessor flag_probability: Float

        attr_accessor flagged: bool

        attr_accessor severity_score: Float

        attr_reader unicode_spoofed: bool?

        def unicode_spoofed=: (bool) -> bool

        def initialize: (
          flag_probability: Float,
          flagged: bool,
          severity_score: Float,
          ?unicode_spoofed: bool
        ) -> void

        def to_hash: -> {
          flag_probability: Float,
          flagged: bool,
          severity_score: Float,
          unicode_spoofed: bool
        }
      end

      type insight =
        ModerationAPI::Models::ContentSubmitResponse::Insight::SentimentInsight
        | ModerationAPI::Models::ContentSubmitResponse::Insight::LanguageInsight

      module Insight
        extend ModerationAPI::Internal::Type::Union

        type sentiment_insight =
          {
            id: :sentiment,
            probability: Float,
            type: :insight,
            value: ModerationAPI::Models::ContentSubmitResponse::Insight::SentimentInsight::value?
          }

        class SentimentInsight < ModerationAPI::Internal::Type::BaseModel
          attr_accessor id: :sentiment

          attr_accessor probability: Float

          attr_accessor type: :insight

          attr_accessor value: ModerationAPI::Models::ContentSubmitResponse::Insight::SentimentInsight::value?

          def initialize: (
            probability: Float,
            value: ModerationAPI::Models::ContentSubmitResponse::Insight::SentimentInsight::value?,
            ?id: :sentiment,
            ?type: :insight
          ) -> void

          def to_hash: -> {
            id: :sentiment,
            probability: Float,
            type: :insight,
            value: ModerationAPI::Models::ContentSubmitResponse::Insight::SentimentInsight::value?
          }

          type value = :positive | :neutral | :negative

          module Value
            extend ModerationAPI::Internal::Type::Enum

            POSITIVE: :positive
            NEUTRAL: :neutral
            NEGATIVE: :negative

            def self?.values: -> ::Array[ModerationAPI::Models::ContentSubmitResponse::Insight::SentimentInsight::value]
          end
        end

        type language_insight =
          { id: :language, probability: Float, type: :insight, value: String? }

        class LanguageInsight < ModerationAPI::Internal::Type::BaseModel
          attr_accessor id: :language

          attr_accessor probability: Float

          attr_accessor type: :insight

          attr_accessor value: String?

          def initialize: (
            probability: Float,
            value: String?,
            ?id: :language,
            ?type: :insight
          ) -> void

          def to_hash: -> {
            id: :language,
            probability: Float,
            type: :insight,
            value: String?
          }
        end

        def self?.variants: -> ::Array[ModerationAPI::Models::ContentSubmitResponse::insight]
      end

      type meta =
        {
          channel_key: String,
          status: ModerationAPI::Models::ContentSubmitResponse::Meta::status,
          timestamp: Float,
          usage: Float,
          processing_time: String
        }

      class Meta < ModerationAPI::Internal::Type::BaseModel
        attr_accessor channel_key: String

        attr_accessor status: ModerationAPI::Models::ContentSubmitResponse::Meta::status

        attr_accessor timestamp: Float

        attr_accessor usage: Float

        attr_reader processing_time: String?

        def processing_time=: (String) -> String

        def initialize: (
          channel_key: String,
          status: ModerationAPI::Models::ContentSubmitResponse::Meta::status,
          timestamp: Float,
          usage: Float,
          ?processing_time: String
        ) -> void

        def to_hash: -> {
          channel_key: String,
          status: ModerationAPI::Models::ContentSubmitResponse::Meta::status,
          timestamp: Float,
          usage: Float,
          processing_time: String
        }

        type status = :success | :partial_success

        module Status
          extend ModerationAPI::Internal::Type::Enum

          SUCCESS: :success
          PARTIAL_SUCCESS: :partial_success

          def self?.values: -> ::Array[ModerationAPI::Models::ContentSubmitResponse::Meta::status]
        end
      end

      type policy =
        ModerationAPI::Models::ContentSubmitResponse::Policy::ClassifierOutput
        | ModerationAPI::Models::ContentSubmitResponse::Policy::EntityMatcherOutput

      module Policy
        extend ModerationAPI::Internal::Type::Union

        type classifier_output =
          {
            id: String,
            flagged: bool,
            probability: Float,
            type: :classifier,
            flagged_fields: ::Array[String],
            labels: ::Array[ModerationAPI::Models::ContentSubmitResponse::Policy::ClassifierOutput::Label]
          }

        class ClassifierOutput < ModerationAPI::Internal::Type::BaseModel
          attr_accessor id: String

          attr_accessor flagged: bool

          attr_accessor probability: Float

          attr_accessor type: :classifier

          attr_reader flagged_fields: ::Array[String]?

          def flagged_fields=: (::Array[String]) -> ::Array[String]

          attr_reader labels: ::Array[ModerationAPI::Models::ContentSubmitResponse::Policy::ClassifierOutput::Label]?

          def labels=: (
            ::Array[ModerationAPI::Models::ContentSubmitResponse::Policy::ClassifierOutput::Label]
          ) -> ::Array[ModerationAPI::Models::ContentSubmitResponse::Policy::ClassifierOutput::Label]

          def initialize: (
            id: String,
            flagged: bool,
            probability: Float,
            ?flagged_fields: ::Array[String],
            ?labels: ::Array[ModerationAPI::Models::ContentSubmitResponse::Policy::ClassifierOutput::Label],
            ?type: :classifier
          ) -> void

          def to_hash: -> {
            id: String,
            flagged: bool,
            probability: Float,
            type: :classifier,
            flagged_fields: ::Array[String],
            labels: ::Array[ModerationAPI::Models::ContentSubmitResponse::Policy::ClassifierOutput::Label]
          }

          type label = { id: String, flagged: bool, probability: Float }

          class Label < ModerationAPI::Internal::Type::BaseModel
            attr_accessor id: String

            attr_accessor flagged: bool

            attr_accessor probability: Float

            def initialize: (
              id: String,
              flagged: bool,
              probability: Float
            ) -> void

            def to_hash: -> { id: String, flagged: bool, probability: Float }
          end
        end

        type entity_matcher_output =
          {
            id: String,
            flagged: bool,
            matches: ::Array[ModerationAPI::Models::ContentSubmitResponse::Policy::EntityMatcherOutput::Match],
            probability: Float,
            type: :entity_matcher,
            flagged_fields: ::Array[String]
          }

        class EntityMatcherOutput < ModerationAPI::Internal::Type::BaseModel
          attr_accessor id: String

          attr_accessor flagged: bool

          attr_accessor matches: ::Array[ModerationAPI::Models::ContentSubmitResponse::Policy::EntityMatcherOutput::Match]

          attr_accessor probability: Float

          attr_accessor type: :entity_matcher

          attr_reader flagged_fields: ::Array[String]?

          def flagged_fields=: (::Array[String]) -> ::Array[String]

          def initialize: (
            id: String,
            flagged: bool,
            matches: ::Array[ModerationAPI::Models::ContentSubmitResponse::Policy::EntityMatcherOutput::Match],
            probability: Float,
            ?flagged_fields: ::Array[String],
            ?type: :entity_matcher
          ) -> void

          def to_hash: -> {
            id: String,
            flagged: bool,
            matches: ::Array[ModerationAPI::Models::ContentSubmitResponse::Policy::EntityMatcherOutput::Match],
            probability: Float,
            type: :entity_matcher,
            flagged_fields: ::Array[String]
          }

          type match =
            { match: String, probability: Float, span: ::Array[Integer] }

          class Match < ModerationAPI::Internal::Type::BaseModel
            attr_accessor match: String

            attr_accessor probability: Float

            attr_accessor span: ::Array[Integer]

            def initialize: (
              match: String,
              probability: Float,
              span: ::Array[Integer]
            ) -> void

            def to_hash: -> {
              match: String,
              probability: Float,
              span: ::Array[Integer]
            }
          end
        end

        def self?.variants: -> ::Array[ModerationAPI::Models::ContentSubmitResponse::policy]
      end

      type recommendation =
        {
          action: ModerationAPI::Models::ContentSubmitResponse::Recommendation::action,
          reason_codes: ::Array[ModerationAPI::Models::ContentSubmitResponse::Recommendation::reason_code]
        }

      class Recommendation < ModerationAPI::Internal::Type::BaseModel
        attr_accessor action: ModerationAPI::Models::ContentSubmitResponse::Recommendation::action

        attr_accessor reason_codes: ::Array[ModerationAPI::Models::ContentSubmitResponse::Recommendation::reason_code]

        def initialize: (
          action: ModerationAPI::Models::ContentSubmitResponse::Recommendation::action,
          reason_codes: ::Array[ModerationAPI::Models::ContentSubmitResponse::Recommendation::reason_code]
        ) -> void

        def to_hash: -> {
          action: ModerationAPI::Models::ContentSubmitResponse::Recommendation::action,
          reason_codes: ::Array[ModerationAPI::Models::ContentSubmitResponse::Recommendation::reason_code]
        }

        type action = :review | :allow | :reject

        module Action
          extend ModerationAPI::Internal::Type::Enum

          REVIEW: :review
          ALLOW: :allow
          REJECT: :reject

          def self?.values: -> ::Array[ModerationAPI::Models::ContentSubmitResponse::Recommendation::action]
        end

        type reason_code =
          :severity_reject
          | :severity_review
          | :author_block
          | :dry_run
          | :trusted_allow
          | :untrusted_severity

        module ReasonCode
          extend ModerationAPI::Internal::Type::Enum

          SEVERITY_REJECT: :severity_reject
          SEVERITY_REVIEW: :severity_review
          AUTHOR_BLOCK: :author_block
          DRY_RUN: :dry_run
          TRUSTED_ALLOW: :trusted_allow
          UNTRUSTED_SEVERITY: :untrusted_severity

          def self?.values: -> ::Array[ModerationAPI::Models::ContentSubmitResponse::Recommendation::reason_code]
        end
      end

      type error = { id: String, message: String }

      class Error < ModerationAPI::Internal::Type::BaseModel
        attr_accessor id: String

        attr_accessor message: String

        def initialize: (id: String, message: String) -> void

        def to_hash: -> { id: String, message: String }
      end
    end
  end
end
