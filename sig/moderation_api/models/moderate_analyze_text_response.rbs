module ModerationAPI
  module Models
    type moderate_analyze_text_response =
      {
        author: ModerationAPI::Models::ModerateAnalyzeTextResponse::Author?,
        content: String,
        content_moderated: bool,
        data_found: bool,
        flagged: bool,
        original: String,
        request: ModerationAPI::Models::ModerateAnalyzeTextResponse::Request,
        status: String,
        unicode_spoofing: bool,
        address: ModerationAPI::Models::ModerateAnalyzeTextResponse::Address,
        content_id: String,
        email: ModerationAPI::Models::ModerateAnalyzeTextResponse::Email,
        error: top,
        name: ModerationAPI::Models::ModerateAnalyzeTextResponse::Name,
        nsfw: ModerationAPI::Models::ModerateAnalyzeTextResponse::Nsfw,
        phone: ModerationAPI::Models::ModerateAnalyzeTextResponse::Phone,
        profanity: ModerationAPI::Models::ModerateAnalyzeTextResponse::Profanity,
        propriety: ModerationAPI::Models::ModerateAnalyzeTextResponse::Propriety,
        quality: ModerationAPI::Models::ModerateAnalyzeTextResponse::Quality,
        sensitive: ModerationAPI::Models::ModerateAnalyzeTextResponse::Sensitive,
        sentiment: ModerationAPI::Models::ModerateAnalyzeTextResponse::Sentiment,
        toxicity: ModerationAPI::Models::ModerateAnalyzeTextResponse::Toxicity,
        url: ModerationAPI::Models::ModerateAnalyzeTextResponse::URL,
        username: ModerationAPI::Models::ModerateAnalyzeTextResponse::Username,
        wordlist: ModerationAPI::Models::ModerateAnalyzeTextResponse::Wordlist,
        wordlists: ::Array[ModerationAPI::Models::ModerateAnalyzeTextResponse::Wordlist]
      }

    class ModerateAnalyzeTextResponse < ModerationAPI::Internal::Type::BaseModel
      attr_accessor author: ModerationAPI::Models::ModerateAnalyzeTextResponse::Author?

      attr_accessor content: String

      attr_accessor content_moderated: bool

      attr_accessor data_found: bool

      attr_accessor flagged: bool

      attr_accessor original: String

      attr_accessor request: ModerationAPI::Models::ModerateAnalyzeTextResponse::Request

      attr_accessor status: String

      attr_accessor unicode_spoofing: bool

      attr_reader address: ModerationAPI::Models::ModerateAnalyzeTextResponse::Address?

      def address=: (
        ModerationAPI::Models::ModerateAnalyzeTextResponse::Address
      ) -> ModerationAPI::Models::ModerateAnalyzeTextResponse::Address

      attr_reader content_id: String?

      def content_id=: (String) -> String

      attr_reader email: ModerationAPI::Models::ModerateAnalyzeTextResponse::Email?

      def email=: (
        ModerationAPI::Models::ModerateAnalyzeTextResponse::Email
      ) -> ModerationAPI::Models::ModerateAnalyzeTextResponse::Email

      attr_reader error: top?

      def error=: (top) -> top

      attr_reader name: ModerationAPI::Models::ModerateAnalyzeTextResponse::Name?

      def name=: (
        ModerationAPI::Models::ModerateAnalyzeTextResponse::Name
      ) -> ModerationAPI::Models::ModerateAnalyzeTextResponse::Name

      attr_reader nsfw: ModerationAPI::Models::ModerateAnalyzeTextResponse::Nsfw?

      def nsfw=: (
        ModerationAPI::Models::ModerateAnalyzeTextResponse::Nsfw
      ) -> ModerationAPI::Models::ModerateAnalyzeTextResponse::Nsfw

      attr_reader phone: ModerationAPI::Models::ModerateAnalyzeTextResponse::Phone?

      def phone=: (
        ModerationAPI::Models::ModerateAnalyzeTextResponse::Phone
      ) -> ModerationAPI::Models::ModerateAnalyzeTextResponse::Phone

      attr_reader profanity: ModerationAPI::Models::ModerateAnalyzeTextResponse::Profanity?

      def profanity=: (
        ModerationAPI::Models::ModerateAnalyzeTextResponse::Profanity
      ) -> ModerationAPI::Models::ModerateAnalyzeTextResponse::Profanity

      attr_reader propriety: ModerationAPI::Models::ModerateAnalyzeTextResponse::Propriety?

      def propriety=: (
        ModerationAPI::Models::ModerateAnalyzeTextResponse::Propriety
      ) -> ModerationAPI::Models::ModerateAnalyzeTextResponse::Propriety

      attr_reader quality: ModerationAPI::Models::ModerateAnalyzeTextResponse::Quality?

      def quality=: (
        ModerationAPI::Models::ModerateAnalyzeTextResponse::Quality
      ) -> ModerationAPI::Models::ModerateAnalyzeTextResponse::Quality

      attr_reader sensitive: ModerationAPI::Models::ModerateAnalyzeTextResponse::Sensitive?

      def sensitive=: (
        ModerationAPI::Models::ModerateAnalyzeTextResponse::Sensitive
      ) -> ModerationAPI::Models::ModerateAnalyzeTextResponse::Sensitive

      attr_reader sentiment: ModerationAPI::Models::ModerateAnalyzeTextResponse::Sentiment?

      def sentiment=: (
        ModerationAPI::Models::ModerateAnalyzeTextResponse::Sentiment
      ) -> ModerationAPI::Models::ModerateAnalyzeTextResponse::Sentiment

      attr_reader toxicity: ModerationAPI::Models::ModerateAnalyzeTextResponse::Toxicity?

      def toxicity=: (
        ModerationAPI::Models::ModerateAnalyzeTextResponse::Toxicity
      ) -> ModerationAPI::Models::ModerateAnalyzeTextResponse::Toxicity

      attr_reader url: ModerationAPI::Models::ModerateAnalyzeTextResponse::URL?

      def url=: (
        ModerationAPI::Models::ModerateAnalyzeTextResponse::URL
      ) -> ModerationAPI::Models::ModerateAnalyzeTextResponse::URL

      attr_reader username: ModerationAPI::Models::ModerateAnalyzeTextResponse::Username?

      def username=: (
        ModerationAPI::Models::ModerateAnalyzeTextResponse::Username
      ) -> ModerationAPI::Models::ModerateAnalyzeTextResponse::Username

      attr_reader wordlist: ModerationAPI::Models::ModerateAnalyzeTextResponse::Wordlist?

      def wordlist=: (
        ModerationAPI::Models::ModerateAnalyzeTextResponse::Wordlist
      ) -> ModerationAPI::Models::ModerateAnalyzeTextResponse::Wordlist

      attr_reader wordlists: ::Array[ModerationAPI::Models::ModerateAnalyzeTextResponse::Wordlist]?

      def wordlists=: (
        ::Array[ModerationAPI::Models::ModerateAnalyzeTextResponse::Wordlist]
      ) -> ::Array[ModerationAPI::Models::ModerateAnalyzeTextResponse::Wordlist]

      def initialize: (
        author: ModerationAPI::Models::ModerateAnalyzeTextResponse::Author?,
        content: String,
        content_moderated: bool,
        data_found: bool,
        flagged: bool,
        original: String,
        request: ModerationAPI::Models::ModerateAnalyzeTextResponse::Request,
        status: String,
        unicode_spoofing: bool,
        ?address: ModerationAPI::Models::ModerateAnalyzeTextResponse::Address,
        ?content_id: String,
        ?email: ModerationAPI::Models::ModerateAnalyzeTextResponse::Email,
        ?error: top,
        ?name: ModerationAPI::Models::ModerateAnalyzeTextResponse::Name,
        ?nsfw: ModerationAPI::Models::ModerateAnalyzeTextResponse::Nsfw,
        ?phone: ModerationAPI::Models::ModerateAnalyzeTextResponse::Phone,
        ?profanity: ModerationAPI::Models::ModerateAnalyzeTextResponse::Profanity,
        ?propriety: ModerationAPI::Models::ModerateAnalyzeTextResponse::Propriety,
        ?quality: ModerationAPI::Models::ModerateAnalyzeTextResponse::Quality,
        ?sensitive: ModerationAPI::Models::ModerateAnalyzeTextResponse::Sensitive,
        ?sentiment: ModerationAPI::Models::ModerateAnalyzeTextResponse::Sentiment,
        ?toxicity: ModerationAPI::Models::ModerateAnalyzeTextResponse::Toxicity,
        ?url: ModerationAPI::Models::ModerateAnalyzeTextResponse::URL,
        ?username: ModerationAPI::Models::ModerateAnalyzeTextResponse::Username,
        ?wordlist: ModerationAPI::Models::ModerateAnalyzeTextResponse::Wordlist,
        ?wordlists: ::Array[ModerationAPI::Models::ModerateAnalyzeTextResponse::Wordlist]
      ) -> void

      def to_hash: -> {
        author: ModerationAPI::Models::ModerateAnalyzeTextResponse::Author?,
        content: String,
        content_moderated: bool,
        data_found: bool,
        flagged: bool,
        original: String,
        request: ModerationAPI::Models::ModerateAnalyzeTextResponse::Request,
        status: String,
        unicode_spoofing: bool,
        address: ModerationAPI::Models::ModerateAnalyzeTextResponse::Address,
        content_id: String,
        email: ModerationAPI::Models::ModerateAnalyzeTextResponse::Email,
        error: top,
        name: ModerationAPI::Models::ModerateAnalyzeTextResponse::Name,
        nsfw: ModerationAPI::Models::ModerateAnalyzeTextResponse::Nsfw,
        phone: ModerationAPI::Models::ModerateAnalyzeTextResponse::Phone,
        profanity: ModerationAPI::Models::ModerateAnalyzeTextResponse::Profanity,
        propriety: ModerationAPI::Models::ModerateAnalyzeTextResponse::Propriety,
        quality: ModerationAPI::Models::ModerateAnalyzeTextResponse::Quality,
        sensitive: ModerationAPI::Models::ModerateAnalyzeTextResponse::Sensitive,
        sentiment: ModerationAPI::Models::ModerateAnalyzeTextResponse::Sentiment,
        toxicity: ModerationAPI::Models::ModerateAnalyzeTextResponse::Toxicity,
        url: ModerationAPI::Models::ModerateAnalyzeTextResponse::URL,
        username: ModerationAPI::Models::ModerateAnalyzeTextResponse::Username,
        wordlist: ModerationAPI::Models::ModerateAnalyzeTextResponse::Wordlist,
        wordlists: ::Array[ModerationAPI::Models::ModerateAnalyzeTextResponse::Wordlist]
      }

      type author =
        {
          id: String,
          block: ModerationAPI::Models::ModerateAnalyzeTextResponse::Author::Block?,
          status: ModerationAPI::Models::ModerateAnalyzeTextResponse::Author::status,
          trust_level: ModerationAPI::Models::ModerateAnalyzeTextResponse::Author::TrustLevel,
          external_id: String?
        }

      class Author < ModerationAPI::Internal::Type::BaseModel
        attr_accessor id: String

        attr_accessor block: ModerationAPI::Models::ModerateAnalyzeTextResponse::Author::Block?

        attr_accessor status: ModerationAPI::Models::ModerateAnalyzeTextResponse::Author::status

        attr_accessor trust_level: ModerationAPI::Models::ModerateAnalyzeTextResponse::Author::TrustLevel

        attr_accessor external_id: String?

        def initialize: (
          id: String,
          block: ModerationAPI::Models::ModerateAnalyzeTextResponse::Author::Block?,
          status: ModerationAPI::Models::ModerateAnalyzeTextResponse::Author::status,
          trust_level: ModerationAPI::Models::ModerateAnalyzeTextResponse::Author::TrustLevel,
          ?external_id: String?
        ) -> void

        def to_hash: -> {
          id: String,
          block: ModerationAPI::Models::ModerateAnalyzeTextResponse::Author::Block?,
          status: ModerationAPI::Models::ModerateAnalyzeTextResponse::Author::status,
          trust_level: ModerationAPI::Models::ModerateAnalyzeTextResponse::Author::TrustLevel,
          external_id: String?
        }

        type block = { reason: String?, until_: Float? }

        class Block < ModerationAPI::Internal::Type::BaseModel
          attr_accessor reason: String?

          attr_accessor until_: Float?

          def initialize: (?reason: String?, ?until_: Float?) -> void

          def to_hash: -> { reason: String?, until_: Float? }
        end

        type status = :enabled | :suspended | :blocked

        module Status
          extend ModerationAPI::Internal::Type::Enum

          ENABLED: :enabled
          SUSPENDED: :suspended
          BLOCKED: :blocked

          def self?.values: -> ::Array[ModerationAPI::Models::ModerateAnalyzeTextResponse::Author::status]
        end

        type trust_level = { level: Float, manual: bool }

        class TrustLevel < ModerationAPI::Internal::Type::BaseModel
          attr_accessor level: Float

          attr_accessor manual: bool

          def initialize: (level: Float, manual: bool) -> void

          def to_hash: -> { level: Float, manual: bool }
        end
      end

      type request = { quota_usage: Float, timestamp: Float }

      class Request < ModerationAPI::Internal::Type::BaseModel
        attr_accessor quota_usage: Float

        attr_accessor timestamp: Float

        def initialize: (quota_usage: Float, timestamp: Float) -> void

        def to_hash: -> { quota_usage: Float, timestamp: Float }
      end

      type address =
        {
          components: top,
          error: String,
          found: bool,
          matches: ::Array[String],
          mode: ModerationAPI::Models::ModerateAnalyzeTextResponse::Address::mode,
          warning: String
        }

      class Address < ModerationAPI::Internal::Type::BaseModel
        attr_reader components: top?

        def components=: (top) -> top

        attr_reader error: String?

        def error=: (String) -> String

        attr_reader found: bool?

        def found=: (bool) -> bool

        attr_reader matches: ::Array[String]?

        def matches=: (::Array[String]) -> ::Array[String]

        attr_reader mode: ModerationAPI::Models::ModerateAnalyzeTextResponse::Address::mode?

        def mode=: (
          ModerationAPI::Models::ModerateAnalyzeTextResponse::Address::mode
        ) -> ModerationAPI::Models::ModerateAnalyzeTextResponse::Address::mode

        attr_reader warning: String?

        def warning=: (String) -> String

        def initialize: (
          ?components: top,
          ?error: String,
          ?found: bool,
          ?matches: ::Array[String],
          ?mode: ModerationAPI::Models::ModerateAnalyzeTextResponse::Address::mode,
          ?warning: String
        ) -> void

        def to_hash: -> {
          components: top,
          error: String,
          found: bool,
          matches: ::Array[String],
          mode: ModerationAPI::Models::ModerateAnalyzeTextResponse::Address::mode,
          warning: String
        }

        type mode = :NORMAL | :SUSPICIOUS | :PARANOID

        module Mode
          extend ModerationAPI::Internal::Type::Enum

          NORMAL: :NORMAL
          SUSPICIOUS: :SUSPICIOUS
          PARANOID: :PARANOID

          def self?.values: -> ::Array[ModerationAPI::Models::ModerateAnalyzeTextResponse::Address::mode]
        end
      end

      type email =
        {
          components: top,
          error: String,
          found: bool,
          matches: ::Array[String],
          mode: ModerationAPI::Models::ModerateAnalyzeTextResponse::Email::mode,
          warning: String
        }

      class Email < ModerationAPI::Internal::Type::BaseModel
        attr_reader components: top?

        def components=: (top) -> top

        attr_reader error: String?

        def error=: (String) -> String

        attr_reader found: bool?

        def found=: (bool) -> bool

        attr_reader matches: ::Array[String]?

        def matches=: (::Array[String]) -> ::Array[String]

        attr_reader mode: ModerationAPI::Models::ModerateAnalyzeTextResponse::Email::mode?

        def mode=: (
          ModerationAPI::Models::ModerateAnalyzeTextResponse::Email::mode
        ) -> ModerationAPI::Models::ModerateAnalyzeTextResponse::Email::mode

        attr_reader warning: String?

        def warning=: (String) -> String

        def initialize: (
          ?components: top,
          ?error: String,
          ?found: bool,
          ?matches: ::Array[String],
          ?mode: ModerationAPI::Models::ModerateAnalyzeTextResponse::Email::mode,
          ?warning: String
        ) -> void

        def to_hash: -> {
          components: top,
          error: String,
          found: bool,
          matches: ::Array[String],
          mode: ModerationAPI::Models::ModerateAnalyzeTextResponse::Email::mode,
          warning: String
        }

        type mode = :NORMAL | :SUSPICIOUS | :PARANOID

        module Mode
          extend ModerationAPI::Internal::Type::Enum

          NORMAL: :NORMAL
          SUSPICIOUS: :SUSPICIOUS
          PARANOID: :PARANOID

          def self?.values: -> ::Array[ModerationAPI::Models::ModerateAnalyzeTextResponse::Email::mode]
        end
      end

      type name_ =
        {
          components: top,
          error: String,
          found: bool,
          matches: ::Array[String],
          mode: ModerationAPI::Models::ModerateAnalyzeTextResponse::Name::mode,
          warning: String
        }

      class Name < ModerationAPI::Internal::Type::BaseModel
        attr_reader components: top?

        def components=: (top) -> top

        attr_reader error: String?

        def error=: (String) -> String

        attr_reader found: bool?

        def found=: (bool) -> bool

        attr_reader matches: ::Array[String]?

        def matches=: (::Array[String]) -> ::Array[String]

        attr_reader mode: ModerationAPI::Models::ModerateAnalyzeTextResponse::Name::mode?

        def mode=: (
          ModerationAPI::Models::ModerateAnalyzeTextResponse::Name::mode
        ) -> ModerationAPI::Models::ModerateAnalyzeTextResponse::Name::mode

        attr_reader warning: String?

        def warning=: (String) -> String

        def initialize: (
          ?components: top,
          ?error: String,
          ?found: bool,
          ?matches: ::Array[String],
          ?mode: ModerationAPI::Models::ModerateAnalyzeTextResponse::Name::mode,
          ?warning: String
        ) -> void

        def to_hash: -> {
          components: top,
          error: String,
          found: bool,
          matches: ::Array[String],
          mode: ModerationAPI::Models::ModerateAnalyzeTextResponse::Name::mode,
          warning: String
        }

        type mode = :NORMAL | :SUSPICIOUS | :PARANOID

        module Mode
          extend ModerationAPI::Internal::Type::Enum

          NORMAL: :NORMAL
          SUSPICIOUS: :SUSPICIOUS
          PARANOID: :PARANOID

          def self?.values: -> ::Array[ModerationAPI::Models::ModerateAnalyzeTextResponse::Name::mode]
        end
      end

      type nsfw =
        {
          error: String,
          label: String,
          label_scores: ModerationAPI::Models::ModerateAnalyzeTextResponse::Nsfw::LabelScores,
          score: Float,
          warning: String
        }

      class Nsfw < ModerationAPI::Internal::Type::BaseModel
        attr_reader error: String?

        def error=: (String) -> String

        attr_reader label: String?

        def label=: (String) -> String

        attr_reader label_scores: ModerationAPI::Models::ModerateAnalyzeTextResponse::Nsfw::LabelScores?

        def label_scores=: (
          ModerationAPI::Models::ModerateAnalyzeTextResponse::Nsfw::LabelScores
        ) -> ModerationAPI::Models::ModerateAnalyzeTextResponse::Nsfw::LabelScores

        attr_reader score: Float?

        def score=: (Float) -> Float

        attr_reader warning: String?

        def warning=: (String) -> String

        def initialize: (
          ?error: String,
          ?label: String,
          ?label_scores: ModerationAPI::Models::ModerateAnalyzeTextResponse::Nsfw::LabelScores,
          ?score: Float,
          ?warning: String
        ) -> void

        def to_hash: -> {
          error: String,
          label: String,
          label_scores: ModerationAPI::Models::ModerateAnalyzeTextResponse::Nsfw::LabelScores,
          score: Float,
          warning: String
        }

        type label_scores = { neutral: Float, sensitive: Float, unsafe: Float }

        class LabelScores < ModerationAPI::Internal::Type::BaseModel
          attr_reader neutral: Float?

          def neutral=: (Float) -> Float

          attr_reader sensitive: Float?

          def sensitive=: (Float) -> Float

          attr_reader unsafe: Float?

          def unsafe=: (Float) -> Float

          def initialize: (
            ?neutral: Float,
            ?sensitive: Float,
            ?unsafe: Float
          ) -> void

          def to_hash: -> { neutral: Float, sensitive: Float, unsafe: Float }
        end
      end

      type phone =
        {
          components: top,
          error: String,
          found: bool,
          matches: ::Array[String],
          mode: ModerationAPI::Models::ModerateAnalyzeTextResponse::Phone::mode,
          warning: String
        }

      class Phone < ModerationAPI::Internal::Type::BaseModel
        attr_reader components: top?

        def components=: (top) -> top

        attr_reader error: String?

        def error=: (String) -> String

        attr_reader found: bool?

        def found=: (bool) -> bool

        attr_reader matches: ::Array[String]?

        def matches=: (::Array[String]) -> ::Array[String]

        attr_reader mode: ModerationAPI::Models::ModerateAnalyzeTextResponse::Phone::mode?

        def mode=: (
          ModerationAPI::Models::ModerateAnalyzeTextResponse::Phone::mode
        ) -> ModerationAPI::Models::ModerateAnalyzeTextResponse::Phone::mode

        attr_reader warning: String?

        def warning=: (String) -> String

        def initialize: (
          ?components: top,
          ?error: String,
          ?found: bool,
          ?matches: ::Array[String],
          ?mode: ModerationAPI::Models::ModerateAnalyzeTextResponse::Phone::mode,
          ?warning: String
        ) -> void

        def to_hash: -> {
          components: top,
          error: String,
          found: bool,
          matches: ::Array[String],
          mode: ModerationAPI::Models::ModerateAnalyzeTextResponse::Phone::mode,
          warning: String
        }

        type mode = :NORMAL | :SUSPICIOUS | :PARANOID

        module Mode
          extend ModerationAPI::Internal::Type::Enum

          NORMAL: :NORMAL
          SUSPICIOUS: :SUSPICIOUS
          PARANOID: :PARANOID

          def self?.values: -> ::Array[ModerationAPI::Models::ModerateAnalyzeTextResponse::Phone::mode]
        end
      end

      type profanity =
        {
          components: top,
          error: String,
          found: bool,
          matches: ::Array[String],
          mode: ModerationAPI::Models::ModerateAnalyzeTextResponse::Profanity::mode,
          warning: String
        }

      class Profanity < ModerationAPI::Internal::Type::BaseModel
        attr_reader components: top?

        def components=: (top) -> top

        attr_reader error: String?

        def error=: (String) -> String

        attr_reader found: bool?

        def found=: (bool) -> bool

        attr_reader matches: ::Array[String]?

        def matches=: (::Array[String]) -> ::Array[String]

        attr_reader mode: ModerationAPI::Models::ModerateAnalyzeTextResponse::Profanity::mode?

        def mode=: (
          ModerationAPI::Models::ModerateAnalyzeTextResponse::Profanity::mode
        ) -> ModerationAPI::Models::ModerateAnalyzeTextResponse::Profanity::mode

        attr_reader warning: String?

        def warning=: (String) -> String

        def initialize: (
          ?components: top,
          ?error: String,
          ?found: bool,
          ?matches: ::Array[String],
          ?mode: ModerationAPI::Models::ModerateAnalyzeTextResponse::Profanity::mode,
          ?warning: String
        ) -> void

        def to_hash: -> {
          components: top,
          error: String,
          found: bool,
          matches: ::Array[String],
          mode: ModerationAPI::Models::ModerateAnalyzeTextResponse::Profanity::mode,
          warning: String
        }

        type mode = :NORMAL | :SUSPICIOUS | :PARANOID

        module Mode
          extend ModerationAPI::Internal::Type::Enum

          NORMAL: :NORMAL
          SUSPICIOUS: :SUSPICIOUS
          PARANOID: :PARANOID

          def self?.values: -> ::Array[ModerationAPI::Models::ModerateAnalyzeTextResponse::Profanity::mode]
        end
      end

      type propriety =
        {
          error: String,
          label: String,
          label_scores: ModerationAPI::Models::ModerateAnalyzeTextResponse::Propriety::LabelScores,
          score: Float,
          warning: String
        }

      class Propriety < ModerationAPI::Internal::Type::BaseModel
        attr_reader error: String?

        def error=: (String) -> String

        attr_reader label: String?

        def label=: (String) -> String

        attr_reader label_scores: ModerationAPI::Models::ModerateAnalyzeTextResponse::Propriety::LabelScores?

        def label_scores=: (
          ModerationAPI::Models::ModerateAnalyzeTextResponse::Propriety::LabelScores
        ) -> ModerationAPI::Models::ModerateAnalyzeTextResponse::Propriety::LabelScores

        attr_reader score: Float?

        def score=: (Float) -> Float

        attr_reader warning: String?

        def warning=: (String) -> String

        def initialize: (
          ?error: String,
          ?label: String,
          ?label_scores: ModerationAPI::Models::ModerateAnalyzeTextResponse::Propriety::LabelScores,
          ?score: Float,
          ?warning: String
        ) -> void

        def to_hash: -> {
          error: String,
          label: String,
          label_scores: ModerationAPI::Models::ModerateAnalyzeTextResponse::Propriety::LabelScores,
          score: Float,
          warning: String
        }

        type label_scores =
          { flirtation: Float, neutral: Float, sexually_explicit: Float }

        class LabelScores < ModerationAPI::Internal::Type::BaseModel
          attr_reader flirtation: Float?

          def flirtation=: (Float) -> Float

          attr_reader neutral: Float?

          def neutral=: (Float) -> Float

          attr_reader sexually_explicit: Float?

          def sexually_explicit=: (Float) -> Float

          def initialize: (
            ?flirtation: Float,
            ?neutral: Float,
            ?sexually_explicit: Float
          ) -> void

          def to_hash: -> {
            flirtation: Float,
            neutral: Float,
            sexually_explicit: Float
          }
        end
      end

      type quality =
        {
          error: String,
          label: String,
          label_scores: ModerationAPI::Models::ModerateAnalyzeTextResponse::Quality::LabelScores,
          score: Float,
          warning: String
        }

      class Quality < ModerationAPI::Internal::Type::BaseModel
        attr_reader error: String?

        def error=: (String) -> String

        attr_reader label: String?

        def label=: (String) -> String

        attr_reader label_scores: ModerationAPI::Models::ModerateAnalyzeTextResponse::Quality::LabelScores?

        def label_scores=: (
          ModerationAPI::Models::ModerateAnalyzeTextResponse::Quality::LabelScores
        ) -> ModerationAPI::Models::ModerateAnalyzeTextResponse::Quality::LabelScores

        attr_reader score: Float?

        def score=: (Float) -> Float

        attr_reader warning: String?

        def warning=: (String) -> String

        def initialize: (
          ?error: String,
          ?label: String,
          ?label_scores: ModerationAPI::Models::ModerateAnalyzeTextResponse::Quality::LabelScores,
          ?score: Float,
          ?warning: String
        ) -> void

        def to_hash: -> {
          error: String,
          label: String,
          label_scores: ModerationAPI::Models::ModerateAnalyzeTextResponse::Quality::LabelScores,
          score: Float,
          warning: String
        }

        type label_scores =
          {
            incoherent: Float,
            neutral: Float,
            spam: Float,
            unsubstantial: Float
          }

        class LabelScores < ModerationAPI::Internal::Type::BaseModel
          attr_reader incoherent: Float?

          def incoherent=: (Float) -> Float

          attr_reader neutral: Float?

          def neutral=: (Float) -> Float

          attr_reader spam: Float?

          def spam=: (Float) -> Float

          attr_reader unsubstantial: Float?

          def unsubstantial=: (Float) -> Float

          def initialize: (
            ?incoherent: Float,
            ?neutral: Float,
            ?spam: Float,
            ?unsubstantial: Float
          ) -> void

          def to_hash: -> {
            incoherent: Float,
            neutral: Float,
            spam: Float,
            unsubstantial: Float
          }
        end
      end

      type sensitive =
        {
          components: top,
          error: String,
          found: bool,
          matches: ::Array[String],
          mode: ModerationAPI::Models::ModerateAnalyzeTextResponse::Sensitive::mode,
          warning: String
        }

      class Sensitive < ModerationAPI::Internal::Type::BaseModel
        attr_reader components: top?

        def components=: (top) -> top

        attr_reader error: String?

        def error=: (String) -> String

        attr_reader found: bool?

        def found=: (bool) -> bool

        attr_reader matches: ::Array[String]?

        def matches=: (::Array[String]) -> ::Array[String]

        attr_reader mode: ModerationAPI::Models::ModerateAnalyzeTextResponse::Sensitive::mode?

        def mode=: (
          ModerationAPI::Models::ModerateAnalyzeTextResponse::Sensitive::mode
        ) -> ModerationAPI::Models::ModerateAnalyzeTextResponse::Sensitive::mode

        attr_reader warning: String?

        def warning=: (String) -> String

        def initialize: (
          ?components: top,
          ?error: String,
          ?found: bool,
          ?matches: ::Array[String],
          ?mode: ModerationAPI::Models::ModerateAnalyzeTextResponse::Sensitive::mode,
          ?warning: String
        ) -> void

        def to_hash: -> {
          components: top,
          error: String,
          found: bool,
          matches: ::Array[String],
          mode: ModerationAPI::Models::ModerateAnalyzeTextResponse::Sensitive::mode,
          warning: String
        }

        type mode = :NORMAL | :SUSPICIOUS | :PARANOID

        module Mode
          extend ModerationAPI::Internal::Type::Enum

          NORMAL: :NORMAL
          SUSPICIOUS: :SUSPICIOUS
          PARANOID: :PARANOID

          def self?.values: -> ::Array[ModerationAPI::Models::ModerateAnalyzeTextResponse::Sensitive::mode]
        end
      end

      type sentiment =
        {
          error: String,
          label: String,
          label_scores: ModerationAPI::Models::ModerateAnalyzeTextResponse::Sentiment::LabelScores,
          score: Float,
          warning: String
        }

      class Sentiment < ModerationAPI::Internal::Type::BaseModel
        attr_reader error: String?

        def error=: (String) -> String

        attr_reader label: String?

        def label=: (String) -> String

        attr_reader label_scores: ModerationAPI::Models::ModerateAnalyzeTextResponse::Sentiment::LabelScores?

        def label_scores=: (
          ModerationAPI::Models::ModerateAnalyzeTextResponse::Sentiment::LabelScores
        ) -> ModerationAPI::Models::ModerateAnalyzeTextResponse::Sentiment::LabelScores

        attr_reader score: Float?

        def score=: (Float) -> Float

        attr_reader warning: String?

        def warning=: (String) -> String

        def initialize: (
          ?error: String,
          ?label: String,
          ?label_scores: ModerationAPI::Models::ModerateAnalyzeTextResponse::Sentiment::LabelScores,
          ?score: Float,
          ?warning: String
        ) -> void

        def to_hash: -> {
          error: String,
          label: String,
          label_scores: ModerationAPI::Models::ModerateAnalyzeTextResponse::Sentiment::LabelScores,
          score: Float,
          warning: String
        }

        type label_scores = { negative: Float, neutral: Float, positive: Float }

        class LabelScores < ModerationAPI::Internal::Type::BaseModel
          attr_reader negative: Float?

          def negative=: (Float) -> Float

          attr_reader neutral: Float?

          def neutral=: (Float) -> Float

          attr_reader positive: Float?

          def positive=: (Float) -> Float

          def initialize: (
            ?negative: Float,
            ?neutral: Float,
            ?positive: Float
          ) -> void

          def to_hash: -> { negative: Float, neutral: Float, positive: Float }
        end
      end

      type toxicity =
        {
          error: String,
          label: String,
          label_scores: ModerationAPI::Models::ModerateAnalyzeTextResponse::Toxicity::LabelScores,
          score: Float,
          warning: String
        }

      class Toxicity < ModerationAPI::Internal::Type::BaseModel
        attr_reader error: String?

        def error=: (String) -> String

        attr_reader label: String?

        def label=: (String) -> String

        attr_reader label_scores: ModerationAPI::Models::ModerateAnalyzeTextResponse::Toxicity::LabelScores?

        def label_scores=: (
          ModerationAPI::Models::ModerateAnalyzeTextResponse::Toxicity::LabelScores
        ) -> ModerationAPI::Models::ModerateAnalyzeTextResponse::Toxicity::LabelScores

        attr_reader score: Float?

        def score=: (Float) -> Float

        attr_reader warning: String?

        def warning=: (String) -> String

        def initialize: (
          ?error: String,
          ?label: String,
          ?label_scores: ModerationAPI::Models::ModerateAnalyzeTextResponse::Toxicity::LabelScores,
          ?score: Float,
          ?warning: String
        ) -> void

        def to_hash: -> {
          error: String,
          label: String,
          label_scores: ModerationAPI::Models::ModerateAnalyzeTextResponse::Toxicity::LabelScores,
          score: Float,
          warning: String
        }

        type label_scores =
          {
            discrimination: Float,
            insult: Float,
            neutral: Float,
            profanity: Float,
            severe_toxicity: Float,
            threat: Float,
            toxicity: Float
          }

        class LabelScores < ModerationAPI::Internal::Type::BaseModel
          attr_reader discrimination: Float?

          def discrimination=: (Float) -> Float

          attr_reader insult: Float?

          def insult=: (Float) -> Float

          attr_reader neutral: Float?

          def neutral=: (Float) -> Float

          attr_reader profanity: Float?

          def profanity=: (Float) -> Float

          attr_reader severe_toxicity: Float?

          def severe_toxicity=: (Float) -> Float

          attr_reader threat: Float?

          def threat=: (Float) -> Float

          attr_reader toxicity: Float?

          def toxicity=: (Float) -> Float

          def initialize: (
            ?discrimination: Float,
            ?insult: Float,
            ?neutral: Float,
            ?profanity: Float,
            ?severe_toxicity: Float,
            ?threat: Float,
            ?toxicity: Float
          ) -> void

          def to_hash: -> {
            discrimination: Float,
            insult: Float,
            neutral: Float,
            profanity: Float,
            severe_toxicity: Float,
            threat: Float,
            toxicity: Float
          }
        end
      end

      type url =
        {
          components: top,
          error: String,
          found: bool,
          matches: ::Array[String],
          mode: ModerationAPI::Models::ModerateAnalyzeTextResponse::URL::mode,
          warning: String
        }

      class URL < ModerationAPI::Internal::Type::BaseModel
        attr_reader components: top?

        def components=: (top) -> top

        attr_reader error: String?

        def error=: (String) -> String

        attr_reader found: bool?

        def found=: (bool) -> bool

        attr_reader matches: ::Array[String]?

        def matches=: (::Array[String]) -> ::Array[String]

        attr_reader mode: ModerationAPI::Models::ModerateAnalyzeTextResponse::URL::mode?

        def mode=: (
          ModerationAPI::Models::ModerateAnalyzeTextResponse::URL::mode
        ) -> ModerationAPI::Models::ModerateAnalyzeTextResponse::URL::mode

        attr_reader warning: String?

        def warning=: (String) -> String

        def initialize: (
          ?components: top,
          ?error: String,
          ?found: bool,
          ?matches: ::Array[String],
          ?mode: ModerationAPI::Models::ModerateAnalyzeTextResponse::URL::mode,
          ?warning: String
        ) -> void

        def to_hash: -> {
          components: top,
          error: String,
          found: bool,
          matches: ::Array[String],
          mode: ModerationAPI::Models::ModerateAnalyzeTextResponse::URL::mode,
          warning: String
        }

        type mode = :NORMAL | :SUSPICIOUS | :PARANOID

        module Mode
          extend ModerationAPI::Internal::Type::Enum

          NORMAL: :NORMAL
          SUSPICIOUS: :SUSPICIOUS
          PARANOID: :PARANOID

          def self?.values: -> ::Array[ModerationAPI::Models::ModerateAnalyzeTextResponse::URL::mode]
        end
      end

      type username =
        {
          components: top,
          error: String,
          found: bool,
          matches: ::Array[String],
          mode: ModerationAPI::Models::ModerateAnalyzeTextResponse::Username::mode,
          warning: String
        }

      class Username < ModerationAPI::Internal::Type::BaseModel
        attr_reader components: top?

        def components=: (top) -> top

        attr_reader error: String?

        def error=: (String) -> String

        attr_reader found: bool?

        def found=: (bool) -> bool

        attr_reader matches: ::Array[String]?

        def matches=: (::Array[String]) -> ::Array[String]

        attr_reader mode: ModerationAPI::Models::ModerateAnalyzeTextResponse::Username::mode?

        def mode=: (
          ModerationAPI::Models::ModerateAnalyzeTextResponse::Username::mode
        ) -> ModerationAPI::Models::ModerateAnalyzeTextResponse::Username::mode

        attr_reader warning: String?

        def warning=: (String) -> String

        def initialize: (
          ?components: top,
          ?error: String,
          ?found: bool,
          ?matches: ::Array[String],
          ?mode: ModerationAPI::Models::ModerateAnalyzeTextResponse::Username::mode,
          ?warning: String
        ) -> void

        def to_hash: -> {
          components: top,
          error: String,
          found: bool,
          matches: ::Array[String],
          mode: ModerationAPI::Models::ModerateAnalyzeTextResponse::Username::mode,
          warning: String
        }

        type mode = :NORMAL | :SUSPICIOUS | :PARANOID

        module Mode
          extend ModerationAPI::Internal::Type::Enum

          NORMAL: :NORMAL
          SUSPICIOUS: :SUSPICIOUS
          PARANOID: :PARANOID

          def self?.values: -> ::Array[ModerationAPI::Models::ModerateAnalyzeTextResponse::Username::mode]
        end
      end

      type wordlist =
        {
          components: top,
          error: String,
          found: bool,
          matches: ::Array[String],
          mode: ModerationAPI::Models::ModerateAnalyzeTextResponse::Wordlist::mode,
          warning: String
        }

      class Wordlist < ModerationAPI::Internal::Type::BaseModel
        attr_reader components: top?

        def components=: (top) -> top

        attr_reader error: String?

        def error=: (String) -> String

        attr_reader found: bool?

        def found=: (bool) -> bool

        attr_reader matches: ::Array[String]?

        def matches=: (::Array[String]) -> ::Array[String]

        attr_reader mode: ModerationAPI::Models::ModerateAnalyzeTextResponse::Wordlist::mode?

        def mode=: (
          ModerationAPI::Models::ModerateAnalyzeTextResponse::Wordlist::mode
        ) -> ModerationAPI::Models::ModerateAnalyzeTextResponse::Wordlist::mode

        attr_reader warning: String?

        def warning=: (String) -> String

        def initialize: (
          ?components: top,
          ?error: String,
          ?found: bool,
          ?matches: ::Array[String],
          ?mode: ModerationAPI::Models::ModerateAnalyzeTextResponse::Wordlist::mode,
          ?warning: String
        ) -> void

        def to_hash: -> {
          components: top,
          error: String,
          found: bool,
          matches: ::Array[String],
          mode: ModerationAPI::Models::ModerateAnalyzeTextResponse::Wordlist::mode,
          warning: String
        }

        type mode = :NORMAL | :SUSPICIOUS | :PARANOID

        module Mode
          extend ModerationAPI::Internal::Type::Enum

          NORMAL: :NORMAL
          SUSPICIOUS: :SUSPICIOUS
          PARANOID: :PARANOID

          def self?.values: -> ::Array[ModerationAPI::Models::ModerateAnalyzeTextResponse::Wordlist::mode]
        end
      end
    end
  end
end
